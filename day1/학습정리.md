# ✏️Terminal
## Terminal 기본 명령어
```
$ pwd        
- (printing working directory)
  현재 디렉토리 경로 표시

$ ls 
- 현재 디렉토리 안에 있는 파일 목록

$ cd 경로
- 디렉토리 이동

$ mkdir 
- 폴더 생성

$ touch index.html = touch 파일명
- 파일 생성

$ cat 
- 파일 내용 보기
```
## git 명령어
1. git init
   - 현재 경로의 디렉토리를 git 저장소로 설정 및 초기화 해주는 명령어
   - mkdir로 폴더 만들고, cd로 해당 경로로 이동해서 git init 입력.
   - 정상적으로 실행되면 "initialized empty Git repository in (경로)"메시지와 함께 설정이 마무리 된다.

2. git add 파일명
   - git이 파일을 추적할 수 있도록 추가해주는 작업
   - add 해야 할 파일이 많은 경우, "git add --all"을 사용하면 추적되고있지 않은 모든 파일을 add 시킨다.
   - commit 전 add 필수

3. git commit -m "commit_description"
   - add 되어있는 상태의 파일을 저장소에 제출.

4. git status
   - 현재 git 저장소의 상태를 표시
   - 변경되었는데 add가 되어있지 않다면 붉은색 파일명, add는 되었으나 commit이 되어있지 않으면 녹색으로 표시한다.

5. git log
   - 현재까지 commit한 기록을 보여준다.
   - 각 커밋별로 사용자, 날짜 및 시간, 커밋 메시지를 보여준다.
   - git log --graph 명령어를 사용하면 커밋 과정에서 브랜치가 나뉘고, 다시 병합되는 과정을 그래프 형식으로 로그와 함께 표시해준다.

<br>

---
<br>
<br>
# ✏️node.js와 npm
## 모듈
- 프로그램은 작고 단순한 것에서 크고 복잡한 것으로 진화한다. 이 과정에서 코드의 재활용성을 높이고, 유지보수를 쉽게 할 수 있는 다양한 기법들이 사용된다. 모듈은 프로그램을 구성하고 있는 수많은 로직들을 조각조각 나눈 부품같은 형태의 파일을 말하고, 이러한 기법을 모듈화라고 한다.
## npm
- npm은 자바스크립트 패키지(모듈) 저장소다. 누구나 npm에 자신이 만든 패키지를 공개할 수 있고, 공개된 패키지를 설치하여 사용할 수 있다. 패키지는 package.json이라는 설정 파일로 관리가 되는데, 패키지 이름, 라이센스 정보, 의존성 등 각종 메타 정보를 포함한다. npm-cli를 제공하여 커맨드 라인 명령어로 패키지를 관리할 수 있다.
- 모듈은 require('module')처럼 가져올 수 있는 파일, 디렉토리다. 모듈은 node_modules 하위에 위치하며 packages.json 파일을 포함한 모듈을 패키지라 부른다.
- node_modules: npm을 통해 설치된 파일은 모두 node_mudules 디렉터리 내에 저장된다.

- [ npm install ] : package.json 내용을 npm 저장소에서 받음. node_modules파일이 생김(의존 라이브러리) npm이 package.json에 명시된 dependencies 부분의 모듈들을 모두 설치해줌.
- [ npm init ]: package.json 생성, 의존성 라이브러리에 대한 정보를 관리

<br>

---
<br>
<br>



# ✏️그 외 여러가지
## switch
```javascript
    switch (expression) {
        case value1:
            statement;
            break;
        case value2:
            statement;
            break;
        ...
        case valueN:
            statement;
            break;
        default:
            statement;
            break;    
    }
```
 1. expression과 valueN이 일치한다면 statement가 실행되고, break가 올 때까지 case절 내부가 실행된다.
 1. break가 오지 않는다면 break가 나올 때까지 다음 case가 진행된다.
 1. 일치하는 case가 없을 때 default가 있으면 default가 실행된다.
 1. 만약 default 전에 일치하는 case가 있고,break가 없어서 default절이 실행될 수도 있다.
   
<br>
<br>

## Math
```javascript
    Math.pow(base, exponent)
    Math.pow(7, 2);  //49
    Math.pow(2, 10); // 1024
```

base의 exponent승을 계산하는 Math 메서드
```javascript
    Math.PI
```
pi값(3.14....)

<br>
<br>

## Rest parameter
```javascript
    function myFun(a, b, ...manyMoreArgs) {
        console.log("a", a); 
        console.log("b", b);
        console.log("manyMoreArgs", manyMoreArgs); 
    }

    myFun("one", "two", "three", "four", "five", "six");

    // Console Output:
    // a, one
    // b, two
    // manyMoreArgs, [three, four, five, six]
```
1. 함수의 마지막 매개변수 앞에 ...을 붙여 모든 나머지 인수를 배열로 대체
2. myFun("one", "two", "three")로 인자가 3개가 들어간다고 하더라도 마지막 인자는 배열이다.(원소가 하나인 배열)
3. myFun("one", "two")로 세 번째 인자가 없으면 manyMoreArgs는 원소가 없는 빈 배열이다.

<br>
<br>

## 객체의 생성자 
 ### [생성자 함수]
  비슷한 객체를 여러 개 만들 때는 객체를 생성하는 함수인 <u>생성자</u>를 이용. 생성자는 관례적으로 대문자로 시작
  
```javascript
    var Human  = function(name, hp, power) {
        this.name = name;
        this.hp = hp;
        this.power = power;
        this.attack = function(target) {
            target.hp -= this.power;
        };
        this.show = function() {
            console.log(
                this.name, this.hp, this.mp, this.power
            );
        };
    };
```
 
 ### [생성자 이용해서 객체 만들기]
  생성자를 이용해서 객체를 만들 때는 <u>new 키워드</u>를 사용.
```javascript
    var m1 = new Human("Eve", 100, 10);
    var m2 = new Human("Crong", 999, 1);
    m1.attack(m2);
    m2.attack(m1);
```
  위 코드에서 m1은 <u>객체</u> 또는 <u>인스턴스</u>라고 한다. m1은 그리고 <u>참조 변수</u>이다.
 
  ### [생성자를 사용하는 이유]
1. 객체를 하나만 만들 때는 간단히 json 표기법으로 만든다.
2. 여러 객체를 만들고 싶을 때는 생성자를 통해서 만든다.



   